= Java Cloud Development Bootstrap
Francesco De Domenico
:toc: left
:source-highlighter: rouge
:icons: font
:doctype: book

== Introduzione

== Risorse

* https://www.baeldung.com/[*Baeldung blog*]: blog con molti tutorials ed esempi sulle librerie ed il framework Spring e Springboot
* https://amzn.to/3UqWkYG[*[ENG\] Pro Spring Boot 2: An Authoritative Guide to Building Microservices, Web and Enterprise Applications, and Best Practices*] - Felipe Gutierrez
* https://amzn.to/3dktGHK[*[ENG\] Pro Spring 5: An In-Depth Guide to the Spring Framework and Its Tools*] - Iuliana Cosmina, Rob Harrop, Chris Schaefer, Clarence Ho 
* https://amzn.to/3dkGgqs[*[ITA\] Concetti di informatica e fondamenti di Java*] -  Cay S. Horstmann


== Prerequisiti

. Fondamenti di Java e programmazione ad oggetti
.. Java 8+
.. Strutture dati: List, Set, Map,
.. Java Generics
.. Bean Injection
.. Stream API => lambda functions
.. Exception handling
.. Java Annotations "@"
.. equals and hashcode: differenze ed usi
.. Project Management tools: Maven & Gradle
.. Data and SW Modeling: UML & ER diagrams
. Network, HTTP & Web
.. Fondamenti:
... com'è fatta una richiesta HTTP?
... Verbo, Headers, Corpo della richiesta, corpo della risposta
... mime-type, Content-Types
... Web markup/notations: HTML, XML, JSON, YAML
... CORS
.. Web Standards
... JWT
... OAuth2: REST + Bearer Token
.. RESTful APIs
.. Che cos'è un webserver?
. DB Transazionali
.. MySQL/MariaDB
.. Creazione tabelle
.. Queries con joins
.. Transazioni
.. Foreign keys
.. Script di inizializzazione tabelle e popolamento database


== Obiettivi
. Source distributed version control systems
.. Git: di cosa si tratta?
... Concetti base: branches, commit, merge, risoluzione dei conflitti, stashing
.. CI/CD: di cosa si tratta?
. Spring + Spring Boot
.. Cos'è un framework? 
.. Cos'è il paradigma MVC?
.. Spring Bean Initialization & @SpringApplication
.. @Component, @Client, @Service, @Controller, @Configuration, @Value
.. Spring @Entity
.. @OneToOne, @OneToMany, @ManyToOne, @ManyToMany
.. Hibernate
.. Spring Repositories
.. JPA Queries
.. Object serialization/deserialization through Jackson
.. Lombok Annotations
.. CrossOrigin
. Docker
.. Docker images, orchestrazione ed interfacciamento con OS host (es: Ports Expose)
.. Dockerfile: struttura e sintassi
... Creazione Dockerfile per applicativo Springboot
.. Docker Compose: struttura e sintassi
... Composizione servizi, volumes, volumes mount
... Comandi compose per esecuzione
. Kubernetes
.. Relazione tra Kubernetes e Docker
.. Worker, node e pods
.. Secrets ed Environment Variables di un deployment Kubernetes

== Corso: Video tutorials

=== git

video::N_bMCff8q6A[youtube, width=800, height=450]

=== Spring Boot

video::vtPkZShrvXQ[youtube, width=800, height=450]

=== Docker

video::3c-iBn73dDE[youtube, width=800, height=450]

=== Kubernetes

video::d6WC5n9G_sM[youtube, width=800, height=450]

== Prima di iniziare

Al fine di installare il software necessario, su Windows, si suggerisce l'installazione del package manager *chocolatey*.

Aprire terminale Powershell ed eseguire:

[source]
--
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
--

Una volta installato il package manager potrà essere utilizzato per installare il software propedeutico allo sviluppo:

[source, powershell]
----
choco install vscode temurin17 maven gradle curl git postman chocolateygui
----

Consigliamo inoltre di avere, su sistemi Windows, degli ambienti shell aggiornati:

[source, powershell]
----
choco install powershell-core microsoft-windows-terminal 
----

per chi utilizzasse shell *nix non ci sono problemi di compatibilità con gli esempi riportati in questa guida, gli utenti windows possono usufruire di un environment linux attraverso la piattaforma Windows Subsystem for Linux. Potete consultare la guida per attivarlo al seguente https://learn.microsoft.com/it-it/training/modules/get-started-with-windows-subsystem-for-linux/[link].

Una volta installato Visual Studio Code installare le seguenti estensioni:

* https://marketplace.visualstudio.com/items?itemName=redhat.java[Language support for Java ™ for Visual Studio Code]
* https://marketplace.visualstudio.com/items?itemName=Pivotal.vscode-boot-dev-pack[Spring Boot Extension Pack]


== Capitolo 1: Getting Started with Spring
=== 1.1 Introduzione

*Spring* nasce come https://it.wikipedia.org/wiki/Framework[framework] per lo sviluppo di applicazioni Server. Al suo interno comprende una collezione di pacchetti nata per facilitare il lavoro degli sviluppatori definendo un pattern preciso di utilizzo.
Utilizzando i paradigmi forniti dal framework è possibile scrivere, grazie all'uso di https://www.baeldung.com/java-decorator-pattern[decoratori], classi concise nel numero di righe di codice ma ricche di funzionalità, ad esempio:

* Creare classi di configurazioni automaticamente popolate con il contenuto di file properties
* Effettuare queries su database scrivendo solo la firma di un metodo
* Creare un'API REST tramite l'uso di un unico decoratore agganciato ad un metodo Java
* ... e molto altro!

*Spring Boot* è un progetto relativamente più recente, nasce con l'esigenza di avere una soluzione facilmente deployabile, self-contained, di server che erogano un determinato servizio. Questo tipo di approccio si è rivelato particolarmente vincente con il nascere di architetture di calcolatori distribuite e containerizzate in quanto Spring Boot fornisce un eseguibile Java contenente tutti i pacchetti e le librerie, compreso un https://en.wikipedia.org/wiki/Web_server[webserver] embedded, da eseguire.

NOTE: Un archivio *jar* che contenga tutto il necessario senza bisogno di librerie esterne è detto *fatjar*. Quando si dispone di tale pacchetto è possibile creare un leggerissimo container per l'esecuzione del servizio contenente soltanto una distro Linux minimale ed una JRE per l'esecuzione dello stesso!

Il framework Spring è costituito da un ecosistema esteso di pacchetti e librerie (spesso frameworks a loro volta). Al fine di gestire tale complesso insieme di software è necessario gestire un progetto Spring tramite un software di distribution management, al momento sono supportati:

* https://maven.apache.org/[Maven]
* https://gradle.org/[Gradle]

Questo tipo di strumenti ci consentono di risolvere le dipendenze esterne del nostro specifico progetto e garantirne la portabilità. Senza questo tipo di strumenti sarebbe di gran lunga più complesso fornire il nostro software a terzi in quanto costoro dovrebbero avere, nel loro CLASSPATH locale, tutte le librerie necessarie ed importate dal software che abbiamo scritto.

Con una soluzione di questo tipo invece dovremo condividere, oltre al codice sorgente della nostra applicazione, solo uno specifico file chiamato *file di distribuzione*:

* *pom.xml* per Maven
* *build.gradle* per Gradle

Spring offre un tool web per la generazione iniziale di un progetto Spring boot chiamato https://start.spring.io/[Spring initializr] attraverso il quale è possibile scegliere i parametri iniziali attraverso cui generare il nostro progetto.

image::./img/springinitializr.png[]

Di particolare importanza sono i parametri:

* Group: che determina il package principale della nostra applicazione Spring
* Artifact: il nome della nostra applicazione(come Java format)
* Name: Il nome della nostra applicazione(come Display name)
* Description: Una descrizione della nostra applicazione
* Package name: tipicamente viene composto automaticamente componendo Group+Artifact - ma è possibile effettuarne l'override
* Il packaging: il tipo di file di output che ci aspettiamo. Tipicamente le applicazioni full embedded, come quelle spring, vengono pacchettizzate sotto forma di jar comprendente tutte le librerie propedeutiche all'esecuzione del nostro software
* Java: la versione target di Java
* Dipendenze: Spring initializr offre un elenco di dipendenze popolari propedeutiche alla generazione di codice automatica, predisposizione controller per API REST, Unit Testing automatico, ecc...

TIP: è possibile aggiungere dipendenze anche dopo la generazione del progetto su spring initializr, semplicemente includendolo nel file di distribuzione come dipendenza

[NOTE] 
.Dove posso trovare altre dipendenze per il mio software?
==== 
Esistono vari motori di ricerca dedicati a questo scopo, uno dei più popolari, vero e proprio punto di riferimento è https://mvnrepository.com/[MVN Repository].

Non solo è possibile generare i tag necessari all'inclusione dei pacchetti nel nostro file di distribuzione, ma vengono anche indicate le vulnerabilità (CVE) delle versioni specifiche di ogni dipendenza.
====

=== 1.2 Il mio primo progetto Spring

Una volta generato il progetto su spring initializr avremo una struttura sul file system fatta in questo modo:

image::./img/demoproject.png[]

I file rilevanti per l'utilizzo sono: 

* DemoApplication.java: file principale dell'applicazione, entry point di Spring Boot
* application.properties: file di configurazione in formato properties java
* DemoApplicationTest.java: file di esempio contenente UnitTests
* pom.xml: file di distribuzione Maven

==== DemoApplication.java

Analizziamo il contenuto di *DemoApplication.java*
[source, java]
----
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}

}
----
Possiamo innanzitutto notare che il package generato è il medesimo scelto inizialmente su spring initializr Group+Name. Successivamente notiamo il decoratore *@SpringBootApplication*

Questo è un decoratore fondamentale per Spring Boot, in quanto dichiara al framework di inizializzare l'applicazione a partire da questa classe e di inizializzare tutti gli https://www.baeldung.com/spring-bean[*Spring Beans*] a partire dal medesimo package della SpringBootApplication stessa.

Di fatti è buona prassi iniziare a creare sotto packages a partire da *package com.example.demo* in modo da garantirne la loro inizialzzazione. Immaginiamo di voler creare un nuovo client HTTP per accedere al servizio XZY, sarebbe bene collocarlo in un package dedicato all'interno del quale creare una classe per lo stesso client quindi:

1. Creeremo il subpackage com.example.demo.xyz.client
2. Al suo interno creeremo una classe chiamata XyzClient.java

IMPORTANT: la naming convention è molto importante per garantire la leggibilità del nostro codice, tipicamente in Java si utilizza la notazione https://en.wikipedia.org/wiki/Camel_case[camelCase] per metodi e variabili. Le classi seguono la medesima convenzione ma iniziano per lettera maiuscola.

==== application.properties

Si tratta di un file di testo contenente le cosiddette *properties* dell'applicazione. Si tratta di valori che non sono hardcoded nell'applicazione ma possono essere modificati *senza ricompilare il progetto*.

Per questa ragione è comodo avere su questo files parametri di configurazioni che possono essere soggetti a modifica nel corso di vita del software che stiamo progettando, ecco alcuni esempi:

* La porta di ascolto di un webserver
* Il path per effettuare una chiamata ad un servizio rest
* La dimensione massima accettata per una determinata richiesta
* Le label di testo presenti su un template HTML
* e molto altro!

==== DemoApplicationTest.java

[source, java]
----
package com.example.demo;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DemoApplicationTests {

	@Test
	void contextLoads() {
	}

}
----

In questo esempio la classe di test è scarna, tuttavia contiene un unico metodo utile che verifica se il *contesto*, ossia l'insieme dei beans e delle classi appartenenti all'applicazione, è stato correttamente inizializzato.

==== pom.xml

il file di distribuzione maven, riportiamo per brevità le parti più importanti:
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.7.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>demo</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

----

=== 1.3 Il mio primo @Controller

Il decoratore *@Controller* (ed anche le sue specializzazioni, come @RestController) è di vitale importanza in un progetto Spring Boot.

Questo tipo di notazione viene utilizzata dal framework Spring per individuare le classi contenenti gli handler che devono essere __bindati__ al webserver embedded (Tomcat è il webserver default).

Inizializziamo un nuovo progetto Spring da https://start.spring.io/[spring initializr] aggiungendo come dipendenza Spring Web

image::./img/spring_web.jpg[]

dopodichè generiamo il progetto iniziale.

Noteremo la solita struttura di progetto ma questa volta il file *pom.xml* avrà una nuova dipendenza


[source, xml]
----
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
----

Aggiungere una dipendenza informa la piattaforma di tooling e runtime che sono disponibili nuovi oggetti Java nel nostro CLASS_PATH, quindi saremo in grado di importare tutta una serie di strumenti che ci aiutino nello sviluppo.

Dobbiamo creare una classe che contenga un @Controller, per prima cosa creiamo un subpackage a partire dal nostro package di default (in questo caso abbiamo lasciato il default di spring initializr com.example.demo).

L'idea è quella di definire una struttura gerarchica che contenga le classi del nostro progetto, in prima istanza, non volendo fare distinzioni di https://it.wikipedia.org/wiki/Dominio_(informatica)[Dominio di business] creeremo un subpackage *controller* che conterrà tutti i controller della nostra applicazione.

Creiamo un primo controller che restituisca all'utente un messaggio di *Hello World!*.

All'interno del package com.example.demo.controller creiamo la classe *HelloWorldController.java*. Il nome della classe è importante, anche se non ha un vero e proprio significato funzionale incoraggiamo l'utilizzo non solo del CamelCase, ma anche di battezzare le classi nel formato {NomeDominio}{NomeComponente}.java - in questo modo siamo già in grado di comprendere la natura ed il ruolo di una classe semplicemente leggendone il nome!

All'interno di una classe decorata con @Controller possiamo definire un insieme di metodi, detti handler, che gestiranno una chiamata http del webserver con i parametri che abbiamo utilizzato per decorare l'handler.

Il nostro desiderio è creare una API che risponda sul path */hello* con verbo *HTTP GET* restituendo la stringa "Hello World!".

[source, java]
----
package com.example.demo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloWorldController {
    
    @RequestMapping(value = "/hello", method = RequestMethod.GET)
    @ResponseBody
    public String helloWorld(){
        return "Hello World!";
    }
}

----

La classe è di facile lettura. La notazione @Controller avvisa il framework che questo file contiene informazioni sugli handlers da bindare sul webserver, tuttavia dobbiamo informare il framework sul *path* e sul *verbo HTTP* necessari per invocare l'handler. In questo caso abbiamo utilizzato il decoratore *@RequestMapping* che al suo interno contiene i parametri *value* e *method* che contengono le informazioni necessarie per esporre la nostra API sul webserver embdedded. In ultimo, informiamo il framework che dovrà essere fornito un response body http di tipo *String*

Dalla root del nostro progetto proviamo a farlo partire con il comando:

[source, shell]
----
> mvn spring-boot:run
----

image::./img/spring_started.jpg[]

Non appena leggeremo _Started DemoApplication_ vorrà dire che il webserver è in ascolto sulla nostra macchina sulla porta 8080 (porta di default).

possiamo a questo punto testare la nostra nuova API

[source, powershell]
----
PS C:\> curl http://localhost:8080/hello
Hello World!
----

La nuova prima API funziona!

In questo corso utilizzeremo nella maggior parte dei case una specializzazione della classe @Controller dedicata all'esposizione di API Rest chiamata *@RestController*. Su questo tipo di classe abbiamo dei decoratori specifici che includono nella loro definizione il verbo HTTP necessario per richiamare l'handler, in questo case useremo *GetMapping*.

Prova a riscrivere il controller *HelloWorldController* sostituendo @Controller e @RequestMapping!

=== 1.4 Passaggio di parametri

Nel capitolo precedente abbiamo imparato cos'è un Controller in Spring e come può essere utilizzato per creare un' API Hello World con pochissime righe di codice. L'API che abbiamo creato può fare ben poco se non rispondere in maniera statica allo stesso modo.

Per fortuna il framework Spring ci consente di programmare il nostro webserver in modo sofisticato, supportando una grande varietà di mime-types e codifica dei parametri HTTP passati. Gran parte del lavoro di ricezione e decodifica degli stessi verrà fatto dal framework, a patto di scrivere correttamente i decoratori da utilizzare per annotare i nostri handler.

Ipotizziamo di voler rendere la nostra API /hello un po' più dinamica, come ad esempio rispondere al nostro nome, se passato come parametro.
Per fare ciò abbiamo molti modi per farlo, ad esempio:

* utilizzare un path parameter
* utilizzare un query string parameter
* un header HTTP agganciato alla richiesta
* un cookie specifico
* un request body

[CAUTION]
====
* È possibile inviare una HTTP Request con body per verbo GET?
* È corretto farlo?
====

Proviamo in prima istanza ad immettere il nostro nome come path parameter, la nostra API dovrà rispondere al path /hello/{name} e restituire al chiamante un corpo della risposta "Hello {name}!".

[source, java]
----
package com.example.demo.controller;


import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
    
    @GetMapping("/hello/{name}")
    public @ResponseBody String helloWorld(
        @PathVariable String name
    ){
        return "Hello %s!".formatted(name);
    }
}
----

Notiamo innanzitutto che abbiamo sostituito @Controller con @RestController e @RequestMapping con @GetMapping, inoltre abbiamo spostato @ResponseBody immediatamente prima del valore di ritorno del metodo, in modo da rendere immediatamente chiaro ad una prima lettura che tipo di dato possiamo aspettarci dall'handler.

Sul path dell'api abbiamo aggiunto un {name}, allo stesso modo abbiamo aggiunto un parametro di input per il metodo helloWorld, ossia una variabile di tipo String chiamata name.

Spring è riesce in automatico a comprendere che l'entità tra parentesi è collegata alla variabile di input del metodo helloWorld, questa variabile sarà dunque correttamente valorizzata (se passata correttamente all'API) e disponibile all'interno del metodo stesso.

Tramite una semplice String format di Java abbiamo decorato la stringa di ritorno con il nostro nome.

Proviamo dunque la nostra API:

image::./img/hello_frenk_path_param.jpg[]

È possibile ottenere il medesimo risultato utilizzando un query string parameter e lasciando il path come impostato inizialmente:

[source, java]
----
package com.example.demo.controller;


import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
    
    @GetMapping("/hello")
    public @ResponseBody String helloWorld(
        @RequestParam String name
    ){
        return "Hello %s!".formatted(name);
    }
}
----
Il codice è estremamente simile al precedente, tuttavia abbiamo annotato il parametro di input del metodo come @RequestParam, pertanto il webserver si attenderà questo parametro come query string paramenter.


image::./img/hello_frenk_req_param.jpg[]

Nella sezione esercizi implementerai l'API anche con i restanti metodi!

=== 1.5 ResponseEntity, Entità custom e DTO

Abbiamo imparato a programmare un controller ed a dichiarare gli handlers per gestire le API, come inviare dati agli handlers e come dichiarare il tipo di risposta che il webserver invierà al chiamante.

Nel paragrafo precedente abbiamo lavorato unicamente dei tipi di dati di tipo stringa ma non abbiamo potuto lavorare su l'oggetto di risposta vero e proprio.

Tipicamente ad una chiamata HTTP spetta una risposta articolata da vari elementi come:

* headers di risposta
* corpo di risposta
* codice di stato

Negli esempi precedenti effettuiamo unicamente il ritorno del dato stringa, ma non possiamo controllare appieno la risposta HTTP alla quale siamo interessati, dopotutto stiamo scrivendo un handler che deve fare proprio questo!

Fortunatamente Spring ha una classe specifica per manipolare la risposta HTTP chiamata https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html[*ResponseEntity*].

ResponseEntity fa leva dei Java Generics per dichiarare il tipo di dato che deve custodire e restituire al chiamante. Inoltre possiamo aggiungere a questo oggetto degli headers custom di risposta nonché lo status code di risposta.

Vediamo un esempio concreto su come utilizzare la ResponseEntity dunque, riscriviamo il precedente esempio di API helloWorld facendo uso di una ResponseEntity!

[source, java]
----
package com.example.demo.controller;


import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
    
    @GetMapping("/hello")
    public @ResponseBody ResponseEntity<String> helloWorld(
        @RequestParam String name
    ){
        String responseBody = "Hello %s!".formatted(name);
        return ResponseEntity.ok(responseBody);
    }
}
----

Abbiamo modificato il metodo helloWorld per restituire una ResponseEntity contenente un tipo String dopodiché abbiamo utilizzato il metodo https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html#ok--[*ok()*] che restituisce un builder per l'oggetto stesso, che accetta come input un oggetto dello stesso tipo indicato nelle parentesi angolari <>, in questo caso il tipo String che restituisce il messaggio di hello.

Consultando la documentazione ufficiale è possibile notare che è presente un builder per ogni stato HTTP più come https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html#notFound--[notFound()], https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html#noContent--[noContent()], https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html#internalServerError--[internalServerError()].

Abbiamo anche la possibilità di definire nella sua interezza la risposta come nell'esempio riportato:

[source, java]
----
package com.example.demo.controller;


import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
	
	@GetMapping("/testBadRequest")
	public @ResponseBody ResponseEntity<String> testBadRequest(){
		return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("BAD_REQUEST");
	}
}
----

In questo caso abbiamo inserito uno stato arbitrario nella risposta, utilizzando la classe di Spring https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html[HttpStatus] per definire il codice http di ritorno. Proviamo ad invocare l'API:

[source, shell]
----
PS C:\> curl http://localhost:8080/testBadRequest -v
*   Trying 127.0.0.1:8080...
* Connected to localhost (127.0.0.1) port 8080 (#0)
> GET /testBadRequest HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.83.1
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 400
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 11
< Date: Fri, 30 Sep 2022 19:53:19 GMT
< Connection: close
<
BAD_REQUEST* Closing connection 0

----

È possibile notare non solo abbiamo ottenuto come corpo della risposta BAD_REQUEST ma abbiamo anche uno status code 400.

Dovrebbe essere chiaro che il paradigma REST si basa su un dialogo fatto tra client e server, di richieste e risposte.

Attraverso una successione di chiamate REST un client può ottenere la fotografia di un sistema, modificane lo stato oppure avviare un processo asincrono (il cui stato può essere verificato sempre tramite chiamate REST).

È possibile veicolare le informazioni sotto forma di risposta in molteplici formati. Uno dei formati più comuni di interscambio è il formato JSON. Spring Boot, in assenza di indicazioni diverse, provvederà a leggere e rispondere alle nostre richieste proprio con il formato JSON!

Al fine di rendere possibile la lettura da parte di Spring Boot della nostra richiesta il framework si appoggia ad una libreria di serializzazione/deserializzazione chiamata https://github.com/FasterXML/jackson[Jackson].

Abbiamo menzionato serializzazione e deserializzazione, ma cosa sono esattamente?

Quando inviamo un @RequestBody utilizzando una chiamata cURL oppure Postman stiamo in realtà trasferendo una sequenza (o serie) di bytes. Questo processo di trasformazione da oggetto a serie di bytes è detto *serializzazione*.

SpringBoot, quando riceve la chiamata, prima di trasferire il controllo al Controller (scusate il gioco di parole), tenta di effettuare il processo inverso, ossia trasformare la sequenza o serie di bytes in un oggetto intellegibile Java. Questo processo è appunto detto *deserializzazione*.

Possiamo quindi passare a SpringBoot oggetti molto sofisticati come @RequestBody, se abbiamo fornito al framework informazioni adeguate potremo utilizzare la richiesta nel nostro codice ed adoperarla in maniera semplice in quanto verrà costruito un vero e proprio oggetto Java! Potremmo quindi utilizzare funzionalità come i Getters ed i Setters per ogni campo, definire all'interno della medesima classe altre classi innestate, utilizzare funzionalità come equals ed hashcode per poter organizzare il nostro oggetto in strutture dati complesse oppure memorizzare la richiesta in un database.

Tipicamente Spring Boot si aspetta che il decoratore @RequestBody sia seguito da una classe Java che rappresenti l'oggetto che ci aspettiamo di ricevere.

Modifichiamo l'API HelloWorld vista in precedenza in modo da ricevere in @RequestBody un oggetto che chiameremo HelloWorldDTO.

Ma che cosa è un DTO? È l'acronimo di https://en.wikipedia.org/wiki/Data_transfer_object[Data transfer object] ed è, in semplici parole, un _contenitore_ di dati.

Come questo contenitore debba essere letto, utilizzato e trasformato sarà poi compito della nostra applicazione, ma a tutti gli effetti abbiamo bisogno di un _wrapper_ che contenga le informazioni contenute nella richiesta in modo da poter essere lette.

Riprendiamo l'esercizio precedente e creiamo un subpackage *dto*, creiamo il file HelloWorldDTO.java al suo interno:

[source, java]
----
package com.example.demo.dto;

import java.util.Objects;

public class HelloWorldDTO {
    private String nome;

    public HelloWorldDTO() {
        super();
    }

    public HelloWorldDTO(String nome) {
        this.nome = nome;
    }

    public String getNome() {
        return this.nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof HelloWorldDTO)) {
            return false;
        }
        HelloWorldDTO helloWorldDTO = (HelloWorldDTO) o;
        return Objects.equals(nome, helloWorldDTO.nome);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(nome);
    }

}
----

Un oggetto java abbastanza semplice, contiene un unico campo privato *nome* e due costruttori, con e senza argomenti di ingresso. Per accedere ai campi dell'oggetto avremo dei getter e dei setter dedicati. Non ci dimentichiamo di implementare gli opportuni metodi *equals* ed *hashCode*, in questo modo abbiamo la garanzia di poter sempre confrontare e gestire in opportune strutture dati gli oggetti della nostra applicazione.

Vediamo ora il controller modificato:

[source, java]
----
package com.example.demo.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.FRestController;

import com.example.demo.dto.HelloWorldDTO;

@RestController
public class HelloWorldController {

    @PostMapping("/hello")
    public @ResponseBody ResponseEntity<String> helloWorld(
            @RequestBody HelloWorldDTO helloWorldDTO) {
        String response = String.format("Hello %s!", helloWorldDTO.getNome());
        return ResponseEntity.ok(response);
    }
}
----

proviamo ad invocare l'API:

[source, powershell]
----
PS> curl -X POST localhost:8080/hello -d '{\"nome\":\"Francesco\"}' -H 'Content-Type: application/json'
Hello Francesco!
----

Utilizzando Powershell è necessario aggiungere il carattere *\* per effettuare l'escaping del doppio apice (") utilizzando una shell linux possiamo semplicemente digitare:

[source, shell]
----
$ curl -X POST localhost:8080/hello -d '{"nome":"francesco"}' -H 'Content-Type: application/json'
Hello francesco!
----

Possiamo notare inoltre l'aggiunta di un header HTTP: *Content-Type: application/json*. Questo header ha fondamentale importanza per il nostro server in quanto fornisce una chiave di lettura per la serie di bytes presenti nel corpo della richiesta HTTP (bisogna effettuare la *deserializzazione* del corpo della richiesta!). Cosa accadrebbe se non lo inviassimo?

[source, shell]
----
$ curl -X POST localhost:8080/hello -d '{"nome":"francesco"}' -v
*   Trying 127.0.0.1:8080...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
> POST /hello HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.68.0
> Accept: */*
> Content-Length: 20
> Content-Type: application/x-www-form-urlencoded
>
* upload completely sent off: 20 out of 20 bytes
* Mark bundle as not supporting multiuse
< HTTP/1.1 415
< Accept: application/json, application/*+json
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 06 Oct 2022 17:08:20 GMT
<
* Connection #0 to host localhost left intact
{"timestamp":"2022-10-06T17:08:20.010+00:00","status":415,"error":"Unsupported Media Type","path":"/hello"}
----

Come possiamo notare cURL in assenza di un'indicazione differente imposta il Content-Type come: *application/x-www-form-urlencoded*. Non avendo istruito il nostro handler all'interno della classe @Controller ad attendersi questo tipo di Content-Type il server ci risponderà che non saprà come gestirlo.



=== Esercizi: Getting Started

Prima di cominciare con gli esercizi veri e propri raccomandiamo la creazione di un repository Git dedicato al rilascio degli esercizi del corso. Si consiglia l'utilizzo di:

* https://github.com/[Github]
* https://about.gitlab.com/[Gitlab]

Si consiglia di prendere familiarità con i seguenti comandi al fine di poter

==== 1.1 Hello World!

Tramite https://start.spring.io/[spring initializr] generare un nuovo progetto Gradle con linguaggio Java 17 e versione Spring 2.7.*.

Aggiungere come dipendenze:
*   Spring Web

Aprire il progetto Gradle tramite VSCode.

Lo scopo dell'esercizio è creare una classe @Controller che effettui il bind sul webserver integrato sul path */hello*.

In particolare il webserver sarà in ascolto sulla porta 8080 e l'API risponderà con un corpo di tipo String.

La risposta desiderata sarà:

[source, shell]
----
	curl http://localhost:8080/hello
	Hello, World!
----

La classe Controller dovrà essere contenuto in un nuovo sub_package del medesimo package di DemoApplication.java

==== 1.2 Request Params

Modificare l'esercizio precedente affinché l'api risponda dinamicamente al nome dell'utente. Il nome utente potrà essere passato con uno dei seguenti parametri opzionali:

* query string parameter *nome*
* path parameter
* HTTP Header
* Cookie value *nome*

Nel caso in cui nessuno di questi parametri sia passato restituire il valore di default *Hello, World!*

==== 1.3 Request Body

Modificare l'API /hello affichè accetti un @RequestBody json con unico parametro *nome* in modo che l'API risponda con il nome dell'utente. L'API Risponderà con verbo POST

==== 1.4 DTO Employee

Creare un subpackage *dto* al cui interno creeremo una classe *Employee*. Employee rappresenta l'impiegato di un determinato dominio aziendale così caratterizzato.

* matricola: intero
* name: testo
* surname: testo
* displayName: name + surname
* birthdate: data di nascita
* sex: m/f
* RAL: intero

In particolare il campo matricola definisce in maniera univoca l'impiegato.

creare un'API GET /employee che restituisca un impiegato fittizio, la risposta attesa dovrà essere:

[source, json]
----
{
    "matricola": 1022891,
    "name": "Mario",
    "surname": "Rossi",
    "displayName": "Mario Rossi",
    "birthdate": "01-01-1989",
    "sex":"m",
    "RAL": 30000
}
----

==== 1.5 Employee List
Creare un'api GET /employees che restituisca una lista di impiegati Employee. Output atteso:
[source, json]
----
[
    {
    "matricola": 1022891,
    "name": "Mario",
    "surname": "Rossi",
    "displayName": "Mario Rossi",
    "birthdate": "01-01-1989",
    "sex":"m",
    "RAL": 30000
    }
    {
    "matricola": 1022892,
    "name": "Flavia",
    "surname": "Rossi",
    "displayName": "Flavia Rossi",
    "birthdate": "02-01-1989",
    "sex":"f",
    "RAL": 30000
    }
]
----

[CAUTION]
====
Quando avete creato l'oggetto Employee, avete definito i metodi equals ed hashcode? Perché sono importanti?
====

==== 1.6 Add Employee
Creare un'api POST /employee che aggiunta un impiegato alla lista esistente di impiegati Employee. Il request body dovrà essere in formato JSON l'API risponde con la lista di impiegati aggiornata.

==== 1.7 Change Employee
Creare un'api PUT /employee/{matricola} che aggiorni la RAL di un impiegato data la sua matricola, il parametro sarà passato come corpo della richiesta in formato x-www-form-urlencoded

==== 1.8 Change Employee (cont.)
Arricchire l'API precedente per modificare qualunque campo dell'impiegato, esclusa la matricola

==== 1.9 Delete Employee
Creare l'API DELETE /employee/{matricola} che consente di aggiornare l'elenco di impiegati in caso di licenziamento o dimissione dell'impiegato con matricola data.

== Capitolo 2: La logica di business e come implementarla

Abbiamo fornito una prima introduzione sul mondo Spring e Springboot, abbiamo implementato i primi controller e scoperto come comunica con i clients. Per costruire servizi sofisticati tuttavia questo non basta. Un @Controller infatti deve descrivere l'interfaccia tra il webserver e l'applicazione vera e propria. Il modello di programmazione ad oggetti scoraggia il popolamento di interfacce con complesse logiche di business/applicative.

La ragione non è realmente funzionale, volendo potremmo scrivere una sofisticatissima applicazione in un unico file e funzionerebbe esattamente come un'applicazione ben progettata, ossia con una rigorosa suddivisione in packages, interfacce chiare ed implementazioni che rispettino il dominio di interesse.

La reale ragione consiste nella leggibilità, manutenibilità ed estensibilità del software che stiamo scrivendo.

Un software ben scritto ci consente inoltre di ben comprendere le eventuali anomalia che si presentano durante la sua esecuzione, agevolando non poco le procedure di troubleshooting.

Il framework Spring incoraggia questo approccio fornendo allo sviluppatore dei beans speciali dedicati a compiti specifici.

=== @Service + @Autowired

Come abbiamo accennato in precedenza, pur essendo sintatticamente corretto, implementare un flusso complicato all'interno di un metodo di un @Controller ne riduce la leggibilità, ed essendo un elemento di interfaccia sarebbe bene tenerlo come mera classe di presentation. 

Spring ha un @Component speciale chiamato @Service. Questo componente è tipicamente quello che ospita la logica di business di un determinato dominio.

Riprendendo il lavoro del capitolo 1 possiamo creare un *HelloWorldService* con un metodo *sayHello* che, dato un DTO HelloWorldDTO restituisca un saluto con il nostro nome.

Vediamo la classe @Service:

[source,java]
----
package com.example.demo.service;

import org.springframework.stereotype.Service;

import com.example.demo.dto.HelloWorldDTO;

@Service
public class HelloWorldService {
    public String sayHello(HelloWorldDTO helloDto){
        return String.format("Hello %s!",helloDto.getNome());
    }
}

----

Sembrerebbe una semplicissima classe Java con un metodo d'istanza che restituisca l'hello world, con qualche piccola eccezione. Innanzitutto l'abbiamo annotata con il decoratore @Service. Avendo inserito questa classe all'interno di un subpackage dell'applicazione principale, Spring Boot inizializzerà questa classe ed i suoi beans all'interno. Notiamo inoltre che non abbiamo dichiarato il costruttore di default, la sua inizializzazione avverrà durante l'avvio del software per via del fatto che @Service è una specializzazione di @Component, e quindi sarà soggetto alle logiche di inizializzazione e bean injection di Spring.

Abbiamo creato dunque la nostra classe di servizio, ma come facciamo a richiamarla all'interno del nostro controller? Ciò che è necessario fare è in qualche modo _collegare_ le classi @Controller e @Service - ciò è possibile trame un @Decoratore particolare detto *Autowired*. Vediamo come potrebbe essere riscritto l'HelloWorldController tramite questa annotazione:

[source, java]
----
package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import com.example.demo.dto.HelloWorldDTO;
import com.example.demo.service.HelloWorldService;

@RestController
public class HelloWorldController {
    @Autowired
    HelloWorldService helloWorldService;

    @PostMapping("/hello")
    public @ResponseBody ResponseEntity<String> helloWorld(
            @RequestBody HelloWorldDTO helloWorldDTO) {
        return ResponseEntity.ok(helloWorldService.sayHello(helloWorldDTO));
    }
}
----

Nuovamente notiamo che non vi è una inizializzazione esplicita dell'oggetto Java HelloWorldService, l'oggetto è stato inizializzato a runtime da Spring e collegato al nostro @RestController tramite la decorazione @Autowired. Per questa ragione, quando invocheremo il metodo di istanza *sayHello*, non riceveremo un NullPointerException ma otterremo il messaggio che ci aspettiamo. Effettuiamo ora il test:

[source, shell]
----
$ curl -X POST http://localhost:8080/hello -d '{"nome": "Francesco"}' -H 'Content-Type:application/json'
Hello Francesco!
----

Abbiamo effettuato il collegamento tra un @Controller ed un @Service, ma niente ci vieta di effettuare in @Autowired il collegamento tra due classi @Service. Questo pattern non è inusuale in quanto è possibile costruire il Service Layer della nostra applicazione componendo tra di loro diversi elementi omogenei.

=== @Component

Il @Component è un decoratore, proprio come @Service, pur non essendo specifico di alcun layer applicativo, abbiamo la possibilità di utilizzarlo proprio come @Service. La sua inizializzazione avverrà a runtime, ed i beans in esso contenuti verranno inizializzati a cascata, purché posto in un subpackage della nostra @SpringApplication.

=== @Configuration

Il decoratore @Configuration è un decoratore speciale in quanto effettua il binding con un file speciale delle nostre applicazioni java chiamato *application.properties*. Si tratta di un file di testo particolare attraverso il quale è possibile inizializzare una mappa di coppie chiave valore, od una lista di elementi.

Perché è importante memorizzare valori in questi files anziché renderli disponibili direttamente nel codice? Modificare un file di test è di gran lunga più conveniente che non ricompilare l'intera applicazione per modificare, ad esempio, una semplice label di testo.

Riportiamo un esempio di application.properties contenente un'unica configurazione, riportandoci all'esempio di HelloWorld immaginiamoci un messaggio di saluto di default da utilizzare in caso non inviassimo alcun nome come parametro

[source, properties]
----
helloworld.defaultmessage="Hello World!"
----
Non appena inseriamo questa linea in application.properties vedremo che il nostro IDE (in questo caso VSCode) ci segnala il seguente messaggio:

image::./img/appproperties_unkown.jpg[]

La property che abbiamo appena dichiarato non fa parte di alcuna property dichiarata nei packages che abbiamo importato (ad esempio non è una property di SprinBoot). Per questa ragione ci invita a dichiararne la tipologia ed a fornire una descrizione della property in modo che chi importa il software comprenda i valori al suo interno.

Per fare ciò creeremo un nuovo file chiamato *additional-spring-configuration-metadata.json* all'interno della cartella ./src/main/resources/META-INF

image::./img/appproperties_additional.jpg[]

al suo interno descriveremo il dominio di valori accettato per la nuova property ed una descrizione:

[source, json]
----
{
    "properties": [
        {
            "name": "helloworld.defaultmessage",
            "type": "java.lang.String",
            "description": "Messaggio di default in caso di assenza helloDto'"
        }
    ]
}

----

A questo punto possiamo creare il nuovo componente Spring @Configuration. Creeremo dunque un subpackage *configuration* che conterrà i file di configurazione della nostra applicazione.

[source, java]
----
package com.example.demo.configuration;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.Objects;

@Configuration
@ConfigurationProperties(prefix = "helloworld")
public class HelloWorldConfiguration {
    String defaultMessage;

    public HelloWorldConfiguration() {
    }

    public HelloWorldConfiguration(String defaultMessage) {
        this.defaultMessage = defaultMessage;
    }

    public String getDefaultMessage() {
        return this.defaultMessage;
    }

    public void setDefaultMessage(String defaultMessage) {
        this.defaultMessage = defaultMessage;
    }

    public HelloWorldConfiguration defaultMessage(String defaultMessage) {
        setDefaultMessage(defaultMessage);
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof HelloWorldConfiguration)) {
            return false;
        }
        HelloWorldConfiguration helloWorldConfiguration = (HelloWorldConfiguration) o;
        return Objects.equals(defaultMessage, helloWorldConfiguration.defaultMessage);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(defaultMessage);
    }

    @Override
    public String toString() {
        return "{" +
                " defaultMessage='" + getDefaultMessage() + "'" +
                "}";
    }

}

----

Oltre al decoratore @Configuration aggiungeremo il decoratore @ConfigurationProperties specificando il prefisso a partire dal quale i campi della classe saranno popolati. Come è possibile notare il nome della variabile è *defaultMessage* è leggermente diverso da quello della property che abbiamo dichiarato *defaultmessage*. Questo disallineamento è voluto in quanto vogliamo dimostrare come Spring, data una classe configuration, consenta allo sviluppatore di scrivere la property in diversi modi. In particolare sarebbe riuscito a leggere qualunque di questi valori:

[source, properties]
----
helloworld.defaultMessage
helloworld.defaultmessage
helloworld.default_message
helloworld.default-message
helloworld.DEFAULT_MESSAGE
----

Come possiamo dunque utilizzare questa @Configuration? Di nuovo, tramite @Autowired !

Modifichiamo dunque la classe HelloWorldService in modo da importare la classe @Configuration e sfruttarla per gli scopi che ci siamo prefissati:

[source, java]
----
package com.example.demo.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.demo.configuration.HelloWorldConfiguration;
import com.example.demo.dto.HelloWorldDTO;

@Service
public class HelloWorldService {
    @Autowired
    HelloWorldConfiguration helloWorldConfiguration;

    public String sayHello(HelloWorldDTO helloDto) {

        if (helloDto == null || helloDto.getNome() == null || "".equals(helloDto.getNome())) {
            return helloWorldConfiguration.getDefaultMessage();
        } else
            return String.format("Hello %s!", helloDto.getNome());
    }
}
----

Per mezzo di @Autowired HelloWorldService sarà in grado di accedere ai campi di HelloWorldConfiguration ed effettuare logica, avete notato che non abbiamo mai invocato il costruttore passando i parametri di application.properties? Questa operazione viene effettuata in automatico dal framework in fase di avvio della nostra applicazione!

Abbiamo modificato il servizio affichè, qualora il DTO fosse nullo, di restituire un messaggio di saluto di default.

Proviamo dunque ad invocare l'API:

[source, shell]
----
curl -X POST http://localhost:8080/hello
{"timestamp":"2022-10-12T07:03:31.517+00:00","status":400,"error":"Bad Request","path":"/hello"}
----

Perchè sta accadendo questo? La ragione potrebbe risiedere nel fatto che stiamo invocando la nostra API senza passare alcun @RequestBody.

In effetti, consultando l'implementazione del decoratore:

[source, java]
----

/**
 * Annotation indicating a method parameter should be bound to the body of the web request.
 * The body of the request is passed through an {@link HttpMessageConverter} to resolve the
 * method argument depending on the content type of the request. Optionally, automatic
 * validation can be applied by annotating the argument with {@code @Valid}.
 *
 * <p>Supported for annotated handler methods.
 *
 * @author Arjen Poutsma
 * @since 3.0
 * @see RequestHeader
 * @see ResponseBody
 * @see org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter
 */
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RequestBody {

	/**
	 * Whether body content is required.
	 * <p>Default is {@code true}, leading to an exception thrown in case
	 * there is no body content. Switch this to {@code false} if you prefer
	 * {@code null} to be passed when the body content is {@code null}.
	 * @since 3.2
	 */
	boolean required() default true;

}
----

Notiamo che lo sviluppatore ci ha lasciato un'indicazione ben precisa riguardo al fatto che, se omesso il campi required, sarà impostato di default a *true*, rendendo obbligatoria la presenza di un request body alla nostra chiamata.

Modifichiamo dunque il controller rendendo il @RequestBody opzionale:

[source, java]
----
@RestController
public class HelloWorldController {
    @Autowired
    HelloWorldService helloWorldService;

    @PostMapping("/hello")
    public @ResponseBody ResponseEntity<String> helloWorld(
            @RequestBody(required = false) HelloWorldDTO helloWorldDTO) {
        return ResponseEntity.ok(helloWorldService.sayHello(helloWorldDTO));
    }
}
----

provando ora ad invocare il servizio:

[source, shell]
----
curl -X POST http://localhost:8080/hello
"Hello, World!"
----

== Soluzioni

[source, java]
----
package com.example.demo.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
    @GetMapping(path="/hello")
    public ResponseEntity<String> helloWorld(){
        return ResponseEntity.ok().body("Hello, World!");
    }
}
----