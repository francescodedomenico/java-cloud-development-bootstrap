= Java Cloud Development Bootstrap
Francesco De Domenico
:toc: left
:source-highlighter: rouge
:icons: font

== Introduzione

== Risorse

* https://www.baeldung.com/[*Baeldung blog*]: blog con molti tutorials ed esempi sulle librerie ed il framework Spring e Springboot
* https://amzn.to/3UqWkYG[*[ENG\] Pro Spring Boot 2: An Authoritative Guide to Building Microservices, Web and Enterprise Applications, and Best Practices*] - Felipe Gutierrez
* https://amzn.to/3dktGHK[*[ENG\] Pro Spring 5: An In-Depth Guide to the Spring Framework and Its Tools*] - Iuliana Cosmina, Rob Harrop, Chris Schaefer, Clarence Ho 
* https://amzn.to/3dkGgqs[*[ITA\] Concetti di informatica e fondamenti di Java*] -  Cay S. Horstmann


== Prerequisiti

. Fondamenti di Java e programmazione ad oggetti
.. Java 8+
.. Strutture dati: List, Set, Map,
.. Java Generics
.. Bean Injection
.. Stream API => lambda functions
.. Exception handling
.. Java Annotations "@"
.. equals and hashcode: differenze ed usi
.. Project Management tools: Maven & Gradle
.. Data and SW Modeling: UML & ER diagrams
. Network, HTTP & Web
.. Fondamenti:
... com'è fatta una richiesta HTTP?
... Verbo, Headers, Corpo della richiesta, corpo della risposta
... mime-type, Content-Types
... Web markup/notations: HTML, XML, JSON, YAML
... CORS
.. Web Standards
... JWT
... OAuth2: REST + Bearer Token
.. RESTful APIs
.. Che cos'è un webserver?
. DB Transazionali
.. MySQL/MariaDB
.. Creazione tabelle
.. Queries con joins
.. Transazioni
.. Foreign keys
.. Script di inizializzazione tabelle e popolamento database


== Obiettivi
. Source distributed version control systems
.. Git: di cosa si tratta?
... Concetti base: branches, commit, merge, risoluzione dei conflitti, stashing
.. CI/CD: di cosa si tratta?
. Spring + Spring Boot
.. Cos'è un framework? 
.. Cos'è il paradigma MVC?
.. Spring Bean Initialization & @SpringApplication
.. @Component, @Client, @Service, @Controller, @Configuration, @Value
.. Spring @Entity
.. @OneToOne, @OneToMany, @ManyToOne, @ManyToMany
.. Hibernate
.. Spring Repositories
.. JPA Queries
.. Object serialization/deserialization through Jackson
.. Lombok Annotations
.. CrossOrigin
. Docker
.. Docker images, orchestrazione ed interfacciamento con OS host (es: Ports Expose)
.. Dockerfile: struttura e sintassi
... Creazione Dockerfile per applicativo Springboot
.. Docker Compose: struttura e sintassi
... Composizione servizi, volumes, volumes mount
... Comandi compose per esecuzione
. Kubernetes
.. Relazione tra Kubernetes e Docker
.. Worker, node e pods
.. Secrets ed Environment Variabiles di un deployment Kubernetes

== Corso: Video tutorials

=== git

video::N_bMCff8q6A[youtube, width=800, height=450]

=== Spring Boot

video::vtPkZShrvXQ[youtube, width=800, height=450]

=== Docker

video::3c-iBn73dDE[youtube, width=800, height=450]

=== Kubernetes

video::d6WC5n9G_sM[youtube, width=800, height=450]

== Prima di iniziare

Al fine di installare il software necessario, su Windows, si suggerisce l'installazione del package manager *chocolatey*.

Aprire terminale Powershell ed eseguire:

[source]
--
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
--

Una volta installato il package manager potrà essere utilizzato per installare il software propedeutico allo sviluppo:

[source, powershell]
----
choco install vscode temurin17 maven gradle curl git postman chocolateygui
----
Una volta installato Visual Studio Code installare le seguenti estensioni:

* https://marketplace.visualstudio.com/items?itemName=redhat.java[Language support for Java ™ for Visual Studio Code]
* https://marketplace.visualstudio.com/items?itemName=Pivotal.vscode-boot-dev-pack[Spring Boot Extension Pack]


== Capitolo 1: Che cos'è Spring? E Spring Boot?
=== 1.1 Introduzione

*Spring* nasce come https://it.wikipedia.org/wiki/Framework[framework] per lo sviluppo di applicazioni Server. Al suo interno comprende una collezione di pacchetti nata per facilitare il lavoro degli sviluppatori definendo un pattern preciso di utilizzo.
Utilizzando i paradigmi forniti dal framework è possibile scrivere, grazie all'uso di https://www.baeldung.com/java-decorator-pattern[decodatori], classi concise nel numero di righe di codice ma ricche di funzionalità, ad esempio:

* Creare classi di configurazioni automaticamente popolate con il contenuto di file properties
* Effettuare queries su database scrivendo solo la firma di un metodo
* Creare un'API REST tramite l'uso di un unico decoratore agganciato ad un metodo Java
* ... e molto altro!

*Spring Boot* è un progetto relativamente più recente, nasce con l'esigenza di avere una soluzione facilmente deployabile, self-contained, di server che erogano un determinato servizio. Questo tipo di approccio si è rivelato particolarmente vincente con il nascere di architetture di calcolatori distribuite e containerizzate in quanto Spring Boot fornisce un eseguibile Java contenente tutti i pacchetti e le librerie, compreso un https://en.wikipedia.org/wiki/Web_server[webserver] embedded, da eseguire.

NOTE: Un archivio *jar* che contenga tutto il necessario senza bisogno di librerie esterne è detto *fatjar*. Quando si dispone di tale pacchetto è possibile creare un leggerissimo container per l'esecuzione del servizio contenente soltanto una distro Linux minimale ed una JRE per l'esecuzione dello stesso!

=== 1.2 Il mio primo progetto Spring


== Esercizi: Getting Started

=== 1.1

Tramite https://start.spring.io/[spring initializr] generare un nuovo progetto Gradle con linguaggio Java 17 e versione Spring 2.7.*.

Aggiungere come dipendenze:
*   Spring Web

Aprire il progetto Gradle tramite VSCode.

Lo scopo dell'esercizio è creare una classe @Controller che effettui il bind sul webserver integrato sul path */hello*.

In particolare il webserver sarà in ascolto sulla porta 8080 e l'API risponderà con un corpo di tipo String.

La risposta desiderata sarà:

[source, shell]
----
curl http://localhost:8080/hello
Hello, World!
----

La classe Controller dovrà essere contenuto in un nuovo sub_package del medesimo package di DemoApplication.java

=== 1.2

Modificare l'esercizio precedente affichè l'api risponda dinamicamente al nome dell'utente. Il nome utente potrà essere passato con uno dei seguenti parametri opzionali:

* query string parameter *nome*
* path parameter
* HTTP Header
* Cookie value *nome*

Nel caso in cui nessuno di questi parametri sia passato restituire il valore di default *Hello, World!*

=== 1.3

Modificare l'API /hello affichè accetti un @RequestBody json con unico parametro *nome* in modo che l'API risponda con il nome dell'utente. L'API Risponderà con verbo POST

=== 1.4

Creare un subpackage *dto* al cui interno creeremo una classe *Employee*. Employee rappresente l'impiegato di un determinato dominio aziendale così caratterizzato.

* matricola: intero
* name: testo
* surname: testo
* displayName: name + surname
* birthdate: data di nascita
* sex: m/f
* RAL: intero

In particolare il campo matricola definisce in maniera univoca l'impiegato.

creare un'API GET /employee che restituisca un impiegato fittizio, la risposta attesa dovrà essere:

[source, json]
----
{
    "matricola": 1022891,
    "name": "Mario",
    "surname": "Rossi",
    "displayName": "Mario Rossi",
    "birthdate": "01-01-1989",
    "sex":"m",
    "RAL": 30000
}
----

=== 1.5
Creare un'api GET /employees che restituisca una lista di impiegati Employee. Output atteso:
[source, json]
----
[
    {
    "matricola": 1022891,
    "name": "Mario",
    "surname": "Rossi",
    "displayName": "Mario Rossi",
    "birthdate": "01-01-1989",
    "sex":"m",
    "RAL": 30000
    }
    {
    "matricola": 1022892,
    "name": "Flavia",
    "surname": "Rossi",
    "displayName": "Flavia Rossi",
    "birthdate": "02-01-1989",
    "sex":"f",
    "RAL": 30000
    }
]
----

[CAUTION]
====
Quando avete creato l'oggetto Employee, avete definito i metodi equals ed hashcode? Perchè sono importanti?
====

=== 1.6
Creare un'api POST /employee che aggiunta un impiegato alla lista esistente di impiegati Employee. Il request body dovrà essere in formato JSON l'API risponde con la lista di impiegati aggiornata.

=== 1.7
Creare un'api PUT /employee/{matricola} che aggiorni la RAL di un impiegato data la sua matricola, il parametro sarà passato come corpo della richiesta in formato x-www-form-urlencoded


== Soluzioni

[source, java]
----
package com.example.demo.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
    @GetMapping(path="/hello")
    public ResponseEntity<String> helloWorld(){
        return ResponseEntity.ok().body("Hello, World!");
    }
}
----