= Java Cloud Development Bootstrap
Francesco De Domenico
:toc: left
:source-highlighter: rouge
:icons: font

== Introduzione

== Risorse

* https://www.baeldung.com/[*Baeldung blog*]: blog con molti tutorials ed esempi sulle librerie ed il framework Spring e Springboot
* https://amzn.to/3UqWkYG[*[ENG\] Pro Spring Boot 2: An Authoritative Guide to Building Microservices, Web and Enterprise Applications, and Best Practices*] - Felipe Gutierrez
* https://amzn.to/3dktGHK[*[ENG\] Pro Spring 5: An In-Depth Guide to the Spring Framework and Its Tools*] - Iuliana Cosmina, Rob Harrop, Chris Schaefer, Clarence Ho 
* https://amzn.to/3dkGgqs[*[ITA\] Concetti di informatica e fondamenti di Java*] -  Cay S. Horstmann


== Prerequisiti

. Fondamenti di Java e programmazione ad oggetti
.. Java 8+
.. Strutture dati: List, Set, Map,
.. Java Generics
.. Bean Injection
.. Stream API => lambda functions
.. Exception handling
.. Java Annotations "@"
.. equals and hashcode: differenze ed usi
.. Project Management tools: Maven & Gradle
.. Data and SW Modeling: UML & ER diagrams
. Network, HTTP & Web
.. Fondamenti:
... com'è fatta una richiesta HTTP?
... Verbo, Headers, Corpo della richiesta, corpo della risposta
... mime-type, Content-Types
... Web markup/notations: HTML, XML, JSON, YAML
... CORS
.. Web Standards
... JWT
... OAuth2: REST + Bearer Token
.. RESTful APIs
.. Che cos'è un webserver?
. DB Transazionali
.. MySQL/MariaDB
.. Creazione tabelle
.. Queries con joins
.. Transazioni
.. Foreign keys
.. Script di inizializzazione tabelle e popolamento database


== Obiettivi
. Source distributed version control systems
.. Git: di cosa si tratta?
... Concetti base: branches, commit, merge, risoluzione dei conflitti, stashing
.. CI/CD: di cosa si tratta?
. Spring + Spring Boot
.. Cos'è un framework? 
.. Cos'è il paradigma MVC?
.. Spring Bean Initialization & @SpringApplication
.. @Component, @Client, @Service, @Controller, @Configuration, @Value
.. Spring @Entity
.. @OneToOne, @OneToMany, @ManyToOne, @ManyToMany
.. Hibernate
.. Spring Repositories
.. JPA Queries
.. Object serialization/deserialization through Jackson
.. Lombok Annotations
.. CrossOrigin
. Docker
.. Docker images, orchestrazione ed interfacciamento con OS host (es: Ports Expose)
.. Dockerfile: struttura e sintassi
... Creazione Dockerfile per applicativo Springboot
.. Docker Compose: struttura e sintassi
... Composizione servizi, volumes, volumes mount
... Comandi compose per esecuzione
. Kubernetes
.. Relazione tra Kubernetes e Docker
.. Worker, node e pods
.. Secrets ed Environment Variabiles di un deployment Kubernetes

== Corso: Video tutorials

=== git

video::N_bMCff8q6A[youtube, width=800, height=450]

=== Spring Boot

video::vtPkZShrvXQ[youtube, width=800, height=450]

=== Docker

video::3c-iBn73dDE[youtube, width=800, height=450]

=== Kubernetes

video::d6WC5n9G_sM[youtube, width=800, height=450]

== Prima di iniziare

Al fine di installare il software necessario, su Windows, si suggerisce l'installazione del package manager *chocolatey*.

Aprire terminale Powershell ed eseguire:

[source]
--
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
--

Una volta installato il package manager potrà essere utilizzato per installare il software propedeutico allo sviluppo:

[source, powershell]
----
choco install vscode temurin17 maven gradle curl git postman chocolateygui
----
Una volta installato Visual Studio Code installare le seguenti estensioni:

* https://marketplace.visualstudio.com/items?itemName=redhat.java[Language support for Java ™ for Visual Studio Code]
* https://marketplace.visualstudio.com/items?itemName=Pivotal.vscode-boot-dev-pack[Spring Boot Extension Pack]


== Capitolo 1: Che cos'è Spring? E Spring Boot?
=== 1.1 Introduzione

*Spring* nasce come https://it.wikipedia.org/wiki/Framework[framework] per lo sviluppo di applicazioni Server. Al suo interno comprende una collezione di pacchetti nata per facilitare il lavoro degli sviluppatori definendo un pattern preciso di utilizzo.
Utilizzando i paradigmi forniti dal framework è possibile scrivere, grazie all'uso di https://www.baeldung.com/java-decorator-pattern[decodatori], classi concise nel numero di righe di codice ma ricche di funzionalità, ad esempio:

* Creare classi di configurazioni automaticamente popolate con il contenuto di file properties
* Effettuare queries su database scrivendo solo la firma di un metodo
* Creare un'API REST tramite l'uso di un unico decoratore agganciato ad un metodo Java
* ... e molto altro!

*Spring Boot* è un progetto relativamente più recente, nasce con l'esigenza di avere una soluzione facilmente deployabile, self-contained, di server che erogano un determinato servizio. Questo tipo di approccio si è rivelato particolarmente vincente con il nascere di architetture di calcolatori distribuite e containerizzate in quanto Spring Boot fornisce un eseguibile Java contenente tutti i pacchetti e le librerie, compreso un https://en.wikipedia.org/wiki/Web_server[webserver] embedded, da eseguire.

NOTE: Un archivio *jar* che contenga tutto il necessario senza bisogno di librerie esterne è detto *fatjar*. Quando si dispone di tale pacchetto è possibile creare un leggerissimo container per l'esecuzione del servizio contenente soltanto una distro Linux minimale ed una JRE per l'esecuzione dello stesso!

Il framework Spring è costituito da un ecosistema esteso di pacchetti e librerie (spesso frameworks a loro volta). Al fine di gestire tale complesso insieme di software è necessario gestire un progetto Spring tramite un software di distribution management, al momento sono supportati:

* https://maven.apache.org/[Maven]
* https://gradle.org/[Gradle]

Questo tipo di strumenti ci consentono di risolvere le dipendenze esterne del nostro specifico progetto e garantirne la portabilità. Senza questo tipo di strumenti sarebbe di gran lunga più complesso fornire il nostro software a terzi in quanto costoro dovrebbero avere, nel loro CLASSPATH locale, tutte le librerie necessarie ed importate dal software che abbiamo scritto.

Con una soluzione di questo tipo invece dovremo condividere, oltre al codice sorgente della nostra applicazione, solo uno specifico file chiamato *file di distribuzione*:

* *pom.xml* per Maven
* *build.gradle* per Gradle

Spring offre un tool web per la generazione iniziale di un progetto Spring boot chiamato https://start.spring.io/[Spring initializr] attraverso il quale è possibile scegliere i parametri iniziali attraverso cui generare il nostro progetto.

image::./img/springinitializr.png[]

Di particolare importanza sono i parametri:

* Group: che determina il package principale della nostra applicazione Spring
* Artifact: il nome della nostra applicazione(come Java format)
* Name: Il nome della nostra applicazione(come Display name)
* Description: Una descrizione della nostra applicazione
* Package name: tipicamente viene composto automaticamente componendo Group+Artifact - ma è possibile effettuarne l'override
* Il packaging: il tipo di file di output che ci aspettiamo. Tipicamente le applicazioni full embedded, come quelle spring, vengono pacchettizzate sotto forma di jar comprendente tutte le librerie propedeutiche all'esecuzione del nostro software
* Java: la versione target di Java
* Dipendenze: Spring initializr offre un elenco di dipendenze popolari propedeutiche alla generazione di codice automatica, predisposizione controller per API REST, Unit Testing automatico, ecc...

TIP: è possibile aggiungere dipendenze anche dopo la generazione del progetto su spring initializr, semplicemente includendolo nel file di distribuzione come dipendenza

[NOTE] 
.Dove posso trovare altre dipendenze per il mio software?
==== 
Esistono vari motori di ricerca dedicati a questo scopo, uno dei più popolari, vero e proprio punto di riferimento è https://mvnrepository.com/[MVN Repository].

Non solo è possibile generare i tag necessari all'inclusione dei pacchetti nel nostro file di distribuzione, ma vengono anche indicate le vulnerabilità (CVE) delle versioni specifiche di ogni dipendenza.
====

=== 1.2 Il mio primo progetto Spring

Una volta generato il progetto su spring initializr avremo una struttura sul file system fatta in questo modo:

image::./img/demoproject.png[]

I file rilevanti per l'utilizzo sono:

* DemoApplication.java: file principale dell'applicazione, entry point di Spring Boot
* application.properties: file di configurazione in formato properties java
* DemoApplicationTest.java: file di esempio contenente UnitTests
* pom.xml: file di distribuzione Maven

Analizziamo il contenuto di *DemoApplication.java*
[source, java]
----
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}

}
----
Possiamo innanzitutto notare che il package generato è il medesimo scelto inizialmente su spring initializr Group+Name. Successivamente notiamo il decoratore *@SpringBootApplication*

Questo è un decoratore fondamentale per Spring Boot, in quanto dichiara al framework di inizializzare l'applicazione a partire da questa classe e di inizializzare tutti gli https://www.baeldung.com/spring-bean[*Spring Beans*] a partire dal medesimo package della SpringBootApplication stessa.

Di fatti è buona prassi iniziare a creare sotto packages a partire da *package com.example.demo* in modo da garantirne la loro inizialzzazione. Immaginiamo di voler creare un nuovo client HTTP per accedere al servizio XZY, sarebbe bene collocarlo in un package dedicato all'interno del quale creare una classe per lo stesso client quindi:

1. Creeremo il subpackage com.example.demo.xyz.client
2. Al suo interno creeremo una classe chiamata XyzClient.java

IMPORTANT: la naming convention è molto importante per garantire la leggibilità del nostro codice, tipicamente in Java si utilizza la notazione https://en.wikipedia.org/wiki/Camel_case[camelCase] per metodi e variabili. Le classi seguono la medesima convenzione ma iniziano per lettera maiuscola.

=== Esercizi: Getting Started

==== 1.1 Hello World!

Tramite https://start.spring.io/[spring initializr] generare un nuovo progetto Gradle con linguaggio Java 17 e versione Spring 2.7.*.

Aggiungere come dipendenze:
*   Spring Web

Aprire il progetto Gradle tramite VSCode.

Lo scopo dell'esercizio è creare una classe @Controller che effettui il bind sul webserver integrato sul path */hello*.

In particolare il webserver sarà in ascolto sulla porta 8080 e l'API risponderà con un corpo di tipo String.

La risposta desiderata sarà:

[source, shell]
----
curl http://localhost:8080/hello
Hello, World!
----

La classe Controller dovrà essere contenuto in un nuovo sub_package del medesimo package di DemoApplication.java

==== 1.2 Request Params

Modificare l'esercizio precedente affichè l'api risponda dinamicamente al nome dell'utente. Il nome utente potrà essere passato con uno dei seguenti parametri opzionali:

* query string parameter *nome*
* path parameter
* HTTP Header
* Cookie value *nome*

Nel caso in cui nessuno di questi parametri sia passato restituire il valore di default *Hello, World!*

==== 1.3 Request Body

Modificare l'API /hello affichè accetti un @RequestBody json con unico parametro *nome* in modo che l'API risponda con il nome dell'utente. L'API Risponderà con verbo POST

==== 1.4 DTO Employee

Creare un subpackage *dto* al cui interno creeremo una classe *Employee*. Employee rappresente l'impiegato di un determinato dominio aziendale così caratterizzato.

* matricola: intero
* name: testo
* surname: testo
* displayName: name + surname
* birthdate: data di nascita
* sex: m/f
* RAL: intero

In particolare il campo matricola definisce in maniera univoca l'impiegato.

creare un'API GET /employee che restituisca un impiegato fittizio, la risposta attesa dovrà essere:

[source, json]
----
{
    "matricola": 1022891,
    "name": "Mario",
    "surname": "Rossi",
    "displayName": "Mario Rossi",
    "birthdate": "01-01-1989",
    "sex":"m",
    "RAL": 30000
}
----

==== 1.5 Employee List
Creare un'api GET /employees che restituisca una lista di impiegati Employee. Output atteso:
[source, json]
----
[
    {
    "matricola": 1022891,
    "name": "Mario",
    "surname": "Rossi",
    "displayName": "Mario Rossi",
    "birthdate": "01-01-1989",
    "sex":"m",
    "RAL": 30000
    }
    {
    "matricola": 1022892,
    "name": "Flavia",
    "surname": "Rossi",
    "displayName": "Flavia Rossi",
    "birthdate": "02-01-1989",
    "sex":"f",
    "RAL": 30000
    }
]
----

[CAUTION]
====
Quando avete creato l'oggetto Employee, avete definito i metodi equals ed hashcode? Perchè sono importanti?
====

==== 1.6 Add Employee
Creare un'api POST /employee che aggiunta un impiegato alla lista esistente di impiegati Employee. Il request body dovrà essere in formato JSON l'API risponde con la lista di impiegati aggiornata.

==== 1.7 Change Employee
Creare un'api PUT /employee/{matricola} che aggiorni la RAL di un impiegato data la sua matricola, il parametro sarà passato come corpo della richiesta in formato x-www-form-urlencoded

==== 1.8 Change Employee (cont.)
Arricchire l'API precedente per modificare qualunque campo dell'impiegato, esclusa la matricola

==== 1.9 Delete Employee
Creare l'API DELETE /employee/{matricola} che consente di aggiornare l'elenco di impiegati in caso di licenziamento o dimissione dell'impiegato con matricola data.

== Soluzioni

[source, java]
----
package com.example.demo.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {
    @GetMapping(path="/hello")
    public ResponseEntity<String> helloWorld(){
        return ResponseEntity.ok().body("Hello, World!");
    }
}
----